num = input().split()
a = float(num[0])
b = float(num[1])
a2 = a  # 用来数小数位数而不影响a
b2 = b  # 用来数小数位数而不影响b
i = 0  # 用来记a的小数位数
j = 0  # 用来记b的小数位数
while a2 % 1 > 1E-6:
    a2 = a2 * 10
    i = i + 1
while b2 % 1 > 1E-6:
    b2 = b2 * 10
    j = j + 1
n = max(i, j)  # 去i和j的最大值

print(f"{a % b:.{n}f}")

"""
但我还是尝试了一些其他方法——这个方法能拿到6分。我也基本理解那4分丢在哪，但是这个思路下很难改了。
基本逻辑是浮点数误差很小，如果我能够正确地规定保留小数，就能忽略这种误差。
简单分析可知，保留小数的位数理应由a和b中小数位数更多的那个来决定。
我经常说编程还挺需要开窍的，也可以从这个例子中看出来——现实生活中我们要确定小数有多少位直接数就行了，电脑不会数小数位数。
开窍的同学就会意识到，数小数位数等价于把小数点右移直到变成整数为止。小数点右移1位等价于*10，变成整数等价于%1=0（这里因为浮点数误差不得不以<1E-6为标准）
这样每一步都是电脑能做的，问题解决了。
所以说虽然我们常说模拟法（用电脑模拟人的思考过程）是编程中可以说最常用的方法。
但是大部分情况下没办法直接移植过来。所以需要首先建立计算机能做什么的意识，然后能够把我们日常的思路抽象归纳并等价到一件电脑能做到的事情。
当然，本程序用了一个目前来说超纲的内容——循环，甚至是循环中不那么常见的while循环（最常见的是for循环）。
大家可以现在就去试图看懂，也可以以后再说，现在领会程序的意思即可。
"""
