num = input().split()
a = num[0]
b = num[1]
i = 0
j = 0
if '.' in a:
    i = len(a.split('.')[1])  # 用split函数，手动设置小数点作为分隔符，那么第二部分就是小数，这部分的长度就是小数位数
if '.' in b:
    j = len(b.split('.')[1])
n = max(i, j)
a = float(a)
b = float(b)

print(f"{a - (a // b * b):.{n}f}")

"""
这个方法甚至只能得到5分。他的基本思路是，我直接在字符串上面操作，看小数点右边的长度，就可以完全精确地得到需要保留的小数位数。
那么看起来问题是，在某些测试数据下，a % b的浮点数误差已经和a/b同精度了
我实在是不知道怎么解决这个问题了
但是我看到有其他人用python大概50B的代码长度就解决了问题，那么想必有一些我没有想到的很简单的方法。
"""
